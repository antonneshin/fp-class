import Data.Char
import Data.List
{-
Явная рекурсия в решениях хотя и допускается, но не приветствуется. Старайтесь обходиться стандартными
функциями, используя при этом создание функций «на лету». Пытайтесь максимально упростить уже написанные
решения, применяя подходящие функции из модуля Data.List и любых других модулей. Перед выполнением заданий
изучите примеры из лекции по функциям высшего порядка. 
-}

{-
 1. Простейшие задачи на применение функций map и filter.
 1.1 Преобразовать данный список целых чисел следующим образом:
  a) увеличить все его элементы в два раза;
  b) увеличить все его элементы с четными значениями в два раза;
  с) обнулить все его элементы с нечетными значениями;
  d) удалить из него элементы, большие заданного числа k;
  e) отфильтровать его, оставив в списке только отрицательные числа;
  f) удалить из него все положительные чётные числа.
-}

f11a :: (Integral a, Eq a) => [a] -> [a]
f11a = map (*2)

f11b :: Integral a => [a] -> [a]
f11b = map (\x -> if x `mod` 2 == 0 then 2*x else x)

f11c :: Integral a => [a] -> [a]
f11c = map (\x -> if x `mod` 2 /= 0 then 0 else x)  
	 
f11d :: Integral a => a -> [a] -> [a]
f11d k = filter (<= k) 

f11e :: Integral a => [a] -> [a]
f11e = filter (< 0) 

f11f :: (Integral a, Eq a) => [a] -> [a]
f11f = filter (\x -> x `mod` 2 /= 0 || x<=0) 

{-
 1.2 Дан список декартовых координат точек на плоскости (пар вещественных чисел).
     Преобразовать его следующим образом:
  a) отфильтровать список так, чтобы в нём остались точки из заданной координатной четверти;
  b) преобразовать декартовы координаты в полярные.
-}

in_quater:: Int -> [(Double, Double)] -> [(Double, Double)]
in_quater k
	| k==1 = filter (\(a, b) -> (a>=0) && (b>=0))
	| k==2 = filter (\(a, b) -> (a<=0) && (b>=0))
	| k==3 = filter (\(a, b) -> (a<=0) && (b<=0))
	| k==4 = filter (\(a, b) -> (a>=0) && (b<=0))

dtop :: [(Double, Double)] -> [(Double, Double)]
dtop = map (\(x, y) -> ( sqrt(x^2 + y^2), if (x>=0) then atan(y/x) else pi + atan(y/x) ) )

prov = map (\x -> if x `mod` 2 == 0 then 2*x else x) 

{-
 1.3 Дан список слов.
  a) Преобразовать все слова к верхнему регистру.
  b) Извлечь из него подсписок слов заданной длины.
  c) Извлечь из него подсписок слов, начинающихся с заданной буквы.
-}

f13a :: [String] -> [String]
f13a = map $ map toUpper
--f13a' = map toUpper

f13b :: Int -> [[a]] -> [[a]]
f13b k = filter (\x -> k == length x)

f13c :: Eq a => a -> [[a]] -> [[a]]
f13c a = filter (\x -> a == head x)


{-
2. Формирование числовых последовательностей (iterate).
 a) Список натуральных чисел, начиная с 0.
 b) Список чётных чисел.
 c) Список элементов последовательности: a0=1, an=(1+an-1)/2.
 d) Список символов английского алфавита.
 e) Список строк, представляющих n-значные двоичные числа.
-}

-- a) Список натуральных чисел, начиная с 0.
nats :: [Integer]
nats = iterate (+1) 0

-- b) Список чётных чисел.
nats_ch :: [Integer]
nats_ch = iterate (+2) 0

-- c) Список элементов последовательности: a0=1, an=(1+an-1)/2.
posled:: [Float]
posled = iterate (\x -> (1 + x)/2 ) 1

-- d) Список символов английского алфавита.
eng_letters :: [Char]
eng_letters = take 26 $ iterate (\x -> chr (ord (x) + 1) ) 'a'

--e) Список строк, представляющих n-значные двоичные числа.
itob :: Int -> [Char]
itob 0 = "0"
itob 1 = "1"
itob n = itob(n `div` 2) ++ [intToDigit(n `mod` 2)] 

btoi :: [Char] -> Int
btoi "0" = 0
btoi "1" = 1
btoi (x:xs) = digitToInt(x) * 2^length(xs) + btoi xs 

binar :: [[Char]]
binar = take 10 $ iterate (\x -> itob $ ((btoi x) + 1) ) "0"

{-
3. Группировка списков.
  a) Дан список символов. Сгруппировать подряд идущие символы по принципу: цифры — не цифры — ...
  b) Дан список пар вещественных чисел (координат точек на плоскости). Сгруппировать подряд идущие
     координаты точек, лежащие в одной координатной четверти.
  c) Дан список и ненулевое натуральное число n. Разбить список на подсписки длиной n каждый.
     Последний подсписок может содержать менее n элементов.
  d) Дан список и ненулевые натуральные числа n и m. Разбить список на перекрывающиеся подсписки
     длиной n элементов со сдвигом относительно предыдущего подсписка на m элементов.
  e) Дан список. Определить длину самого длинного подсписка, содержащего подряд идущие одинаковые элементы.
-}

f3a :: [Char] -> [Char]
f3a xs = (filter (\x -> x `elem` ['0','1','2','3','4', '5', '6', '7', '8', '9'] ) xs) ++ (filter (\x -> not (x `elem` ['0','1','2','3','4', '5', '6', '7', '8', '9']) ) xs)

f3b :: (Num a, Num a1, Ord a, Ord a1) => [(a, a1)] -> [(a, a1)]
f3b xs = (filter (\(x, y) -> (x>=0) && (y>=0) ) xs) ++ (filter (\(x, y) -> (x<=0) && (y>=0) ) xs) ++ (filter (\(x, y) -> (x<=0) && (y<=0) ) xs) ++ (filter (\(x, y) -> (x>=0) && (y<=0) ) xs)

f3c :: [a] -> Int -> [[a]]
f3c [] _ = []
f3c xs n = [take n xs] ++ f3c (drop n xs) n

f3d :: [a] -> Int -> Int -> [[a]]
f3d [] _ _ = []
f3d xs n m = [take n xs] ++ f3d (drop m xs) n m
-- Должно быть True
test_f3d = f3d [1..10] 4 2 == [[1,2,3,4],[3,4,5,6],[5,6,7,8],[7,8,9,10],[9,10]]

lenlist :: Eq a => [a] -> Int
lenlist xs = head $ reverse $ sort $ [length x | x <- group xs]

{-
4. Разные задачи.
 a) Дан текст в виде строки символов, содержащий среди прочего числовые данные. Посчитать количество
    всех упоминающихся в тексте чисел.
 b) Найти сумму всех чисел Фибоначчи, удовлетворяющих заданному предикату, в указанном промежутке
    (например: все чётные от 1 до 106).
 c) Дана строка текста и число n. Сформировать список, содержащий n самых часто используемых
    в строке символов.
 d) Дан список чисел. Сформировать список локальных максимумов исходного списка. Локальным максимумом
    называется элемент, больший своих соседей.
 e) Дан список. Продублировать все его элементы.
-}

f4a :: [Char] -> Int
f4a xs = length $ group $ filter (\x -> x `elem` ['0','1','2','3','4', '5', '6', '7', '8', '9'] ) xs

fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

f4b :: Integer
f4b = sum $ filter (\x -> (x `mod` 7 == 0) || (x `mod` 77 == 0) ) (take 128 fibs)

f4c :: Ord t => [t] -> Int -> [[t]]
f4c xs n = map (\x -> [snd x] ) $ take n $ reverse $ sort $ [(length x, head x) | x <- group $ sort xs]

lmax (x:[]) = []
--lmax xs = [ max x y | x, y <- xs]


f4d' [] = []
f4d' (x:[]) = [x]
f4d' (x:y:[]) = [max x y]
f4d' (x:y:z:xs) = (max z $ (max x y)) : if xs == [] then f4d' (y:z:xs) else f4d' (z:xs)

f4d (x:xs) = zipWith (max) xs (take ((length xs)) (x:xs)) 

f4e [] = []
f4e (x:xs) = [x] ++ [x] ++ f4e xs 




